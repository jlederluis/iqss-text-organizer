#!/usr/bin/env python

import clint
import sys
import os
import lucene
from textorganizer import indexfiles, searchfiles, addmetadata, stemmingtools, indexutils

class TextOrganizer:
    def __init__(self,lucenedir,programdir=None):
        self.lucenedir = lucenedir
        # if no program dir is supplied, default to home directory
        self.programdir = programdir if programdir is not None else os.path.expanduser("~") 
        #lucene object containing selected documents
        self.scoreDocs = None
        #list of all terms in selected documents
        self.allTerms = None
        #dictionary containing TDM for selected documents        
        self.allDicts = None
        #This is the analyzer used for searching and indexing. Defaults to English

        self.analyzers = {}

        self.analyzers['StandardAnalyzer'] = lucene.StandardAnalyzer(lucene.Version.LUCENE_CURRENT)

        try:
            self.analyzers['SmartChineseAnalyzer'] = lucene.SmartChineseAnalyzer(lucene.Version.LUCENE_CURRENT)
        except:
            print "SmartChineseAnalyzer not found"

        try:
            self.analyzers['PorterStemmerAnalyzer'] = stemmingtools.init_PSA(os.path.join(self.programdir,"phrases.txt"))
        except:
            print "PorterStemmerAnalyzer not found."            

        self.active_analyzer = 'StandardAnalyzer'

    
    def parseargs(self,grouped_args):

        if '-a' in grouped_args:
            if len(grouped_args['-a']) == 1:
                add_files = True
            elif len(grouped_args['-a']) == 0:
                print 'Add_files flag passed, but no directory given. Ignoring -a flag.'
                add_files = False
            elif len(grouped_args['-a']) > 1:
                print 'Only one directory may be passed to txtorg -a. Ignoring -a flag.'
                add_files = False
        else:
            add_files = False

        if '-c' in grouped_args:
            if len(grouped_args['-c']) == 1:
                add_md = True
            elif len(grouped_args['-c']) == 0:
                print 'Import_metadata flag passed, but no CSV file given. Ignoring -c flag.'
                add_md = False
            elif len(grouped_args['-c']) > 1:
                print 'Only one CSV file may be passed to txtorg -c. Ignoring -c flag.'
                add_md = False
        else:
            add_md = False

        if '-C' in grouped_args:
            if len(grouped_args['-C']) == 1:
                add_new_md = True
            elif len(grouped_args['-C']) == 0:
                print 'Import new files from CSV flag passed, but no CSV file given. Ignoring -C flag.'
                add_new_md = False
            elif len(grouped_args['-C']) > 1:
                print 'Only one CSV file may be passed to txtorg -C. Ignoring -C flag.'
                add_new_md = False
        else:
            add_new_md = False

        if '-n' in grouped_args:
            self.active_analyzer = self.change_analyzer()

        # first, add new files from csv if -C was passed
        if add_new_md:
            self.add_metadata(grouped_args['-C'][0],new_files=True)

        # next, add files from a directory if -a was passed
        if add_files:
            indexfiles.IndexFiles(grouped_args['-a'][0],self.lucenedir,self.analyzers[self.active_analyzer])

        # next, update documents with metadata if -c was passed
        if add_md:
            self.add_metadata(grouped_args['-c'][0])
    

        self.mainprompt()

    def mainprompt(self):
        print "Entering interactive mode. Type 'h' or 'help' for supported syntax."

        while True:
        #present user with a prompt, grab input, and convert to lowercase
            instr=raw_input("> ").lower()

            if instr == 'q' or instr == 'quit' or instr == 'exit':
                break
            elif instr.startswith('select '):
                self.run_searcher(instr[7:])
            elif instr.startswith('export tdm'):
                self.export_tdm()
            elif instr.startswith('export files'):
                self.export_files()
            elif instr.startswith('export metadata'):
                self.export_metadata()
            elif instr.startswith('view fields'):
                self.view_fields()
            elif instr.startswith('analyzer'):
                self.active_analyzer = self.change_analyzer(instr[9:])
            elif instr.startswith('index'):
                self.change_index()
            elif instr.startswith('clear'):
                self.clear_selections()
            elif instr.startswith('cleanup'):
                self.cleanup_index()
            elif instr == 'h' or instr == 'help':
                self.show_help()
            else:
                print "Input not understood. Type 'h' or 'help' for help."

    def change_index(self):
        print "Available Lucene indices:\n"

        available_indices = []
        with open(os.path.join(self.programdir, 'available_indices')) as inf:
            for idx, line in enumerate(inf):
                if line.strip() == self.lucenedir:
                    print "* " + str(idx + 1).ljust(5, ' ') + line.strip()
                else:
                    print "  " + str(idx + 1).ljust(5, ' ') + line.strip()
                available_indices.append(line.strip())

        print "\nType the number corresponding to the desired Lucene index, or type 'n' to create a new one."

        while True:
            choice = raw_input('> ').lower()
            if choice not in [str(x + 1) for x in range(idx + 1)] + ['n','q']:
                print "Not a valid selection. Type a number to select an existing index, 'n' to create a new index, or 'q' to cancel."
                continue
            else:
                break
        
        if choice in [str(x + 1) for x in range(idx + 1)]:
            # set lucenedir to selection, and write available_indices back to file with the
            # selected one first (making it default until changed again)
            self.lucenedir = available_indices[int(choice) - 1]
            with open(os.path.join(self.programdir, 'available_indices'), 'w') as outf:
                outf.write(self.lucenedir + '\n')
                for line in filter(lambda x: x != self.lucenedir, available_indices):
                    outf.write(line+'\n')

        elif choice == 'q':
            print "Canceled. Current index:", self.lucenedir
            return
        elif choice == 'n':
            print "Please type the path pointing to the Lucene index you would like to open or create."
            while True:
                rawpath = raw_input('> ')
                if rawpath.lower() == 'q': 
                    print "Canceled. Current index:", self.lucenedir
                    return
                try:
                    expanded_path = os.path.realpath(os.path.expanduser(rawpath))
                    if not os.path.exists(expanded_path):
                        # make a new index
                        os.mkdir(expanded_path)
                        analyzer = lucene.StandardAnalyzer(lucene.Version.LUCENE_CURRENT)
                        writer = lucene.IndexWriter(lucene.SimpleFSDirectory(lucene.File(expanded_path)), analyzer, True, lucene.IndexWriter.MaxFieldLength.LIMITED)
                        writer.setMaxFieldLength(1048576)
                        writer.optimize()
                        writer.close()

                    if not os.path.isdir(expanded_path):
                        raise OSError

                    self.lucenedir = expanded_path
                    break
                except OSError:
                    print "File path not understood. Please try again or type 'q' to quit."
                    continue

            with open(os.path.join(self.programdir, 'available_indices'), 'w') as outf:
                outf.write(self.lucenedir + '\n')
                for line in available_indices:
                    outf.write(line+'\n')

        self.scoreDocs = None
        self.allTerms = None
        self.allDicts = None

        print "Index changed to", self.lucenedir
        

        

    def change_analyzer(self,analyzer=None):
        if analyzer is None or analyzer not in self.analyzers.keys():
            print """Available Analyzers:"""
            for idx,analyzer_str in enumerate(self.analyzers.keys()):
                print "%s) %s" % (str(idx+1),analyzer_str)

            print "Choose which analyzer to use (e.g. type 1 for %s), or leave blank to keep current analyzer (%s)" % (self.analyzers.keys()[0], self.active_analyzer,)
            choice = raw_input('> ')
        else:
            choice = analyzer

        if choice == '': return self.active_analyzer

        try:
            return self.analyzers.keys()[int(choice)-1]
        except (IndexError, ValueError,):
            print "Could not understand input. Defaulting to %s." % (self.analyzers.keys()[0],)
            return self.analyzers.keys()[0]


    def cleanup_index(self):
        ic = indexutils.IndexCleaner(self.lucenedir)
        ic.cleanup_index()

    def add_metadata(self,csvfile,new_files=False):
        directory = lucene.SimpleFSDirectory(lucene.File(self.lucenedir))
        searcher = lucene.IndexSearcher(directory, True)
        reader = lucene.IndexReader.open(directory, True)
        writer = lucene.IndexWriter(directory, self.analyzers[self.active_analyzer], False, lucene.IndexWriter.MaxFieldLength.LIMITED)

        addmetadata.add_metadata_from_csv(searcher,reader,writer,csvfile,new_files)
        writer.close()
        
    def run_searcher(self,command):
        directory = lucene.SimpleFSDirectory(lucene.File(self.lucenedir))
        searcher = lucene.IndexSearcher(directory, True)
        reader = lucene.IndexReader.open(directory, True)

        try:
            print "Running Lucene query \"%s\"" % (command,)
            new_scoreDocs, new_allTerms, new_allDicts = searchfiles.run(searcher, self.analyzers[self.active_analyzer], reader, command)

            if self.scoreDocs is None or self.allTerms is None or self.allDicts is None:
                self.scoreDocs, self.allTerms, self.allDicts = new_scoreDocs, new_allTerms, new_allDicts
            else:
                # intersect active search with this one
                print 'Searching within previous selection. To clear your selections, type "clear"'
                new_scoredoc_ids = [d.doc for d in new_scoreDocs]
                intersected_scoredoc_indices = [i for i in range(len(self.scoreDocs)) if self.scoreDocs[i].doc in new_scoredoc_ids]

                self.scoreDocs = [self.scoreDocs[i] for i in intersected_scoredoc_indices]
                self.allTerms = set(self.allTerms).intersection(new_allTerms)
                self.allDicts = [self.allDicts[i] for i in intersected_scoredoc_indices]
                
        except lucene.JavaError as e:
            if 'ParseException' in str(e):
                print "Invalid query; see Lucene documentation for information on query syntax"
            elif 'IllegalArgumentException' in str(e):
                print "Index is empty and cannot be queried"
            else:
                raise e

        print "%s total matching documents." % len(self.scoreDocs)
        print "%s total unique terms." % len(self.allTerms)
        searcher.close()

    def clear_selections(self):
        print "Selections cleared."
        self.scoreDocs = None
        self.allTerms = None
        self.allDicts = None


    def view_fields(self):
        if (self.scoreDocs is None) or (self.allTerms is None) or (self.allDicts is None):
            print "Select documents with \"select [query]\" before exporting TDM"
            return False

        directory = lucene.SimpleFSDirectory(lucene.File(self.lucenedir))
        searcher = lucene.IndexSearcher(directory, True)

        for count,scoreDoc in enumerate(self.scoreDocs):
            doc = searcher.doc(scoreDoc.doc)
            print '\nDocument {0}:'.format(count)
            for f in doc.getFields():
                field = lucene.Field.cast_(f)
                (k, v) = field.name(), field.stringValue()
                print "{0}: {1}".format(k,v)

    def export_tdm(self):
        if (self.scoreDocs is None) or (self.allTerms is None) or (self.allDicts is None):
            print "Select documents with \"select [query]\" before exporting TDM"
            return 

        print "Choose a file for export (leave blank to accept default -> ./tdm.txt)"
        outfile = './tdm.csv'
        outfile_raw = raw_input("> ")
        if outfile_raw == "":
            outfile = os.path.realpath(outfile)
        else:
            outfile = os.path.realpath(os.path.expanduser(outfile_raw))

        print "Exporting TDM to ", outfile
        # searchfiles.writeTDM(self.allDicts, self.allTerms, outfile)
        searchfiles.write_CTM_TDM(self.scoreDocs, self.allDicts, self.allTerms, self.lucenedir, outfile)

    def choose_or_create_dir(self,default):

        print "Choose a directory for export (leave blank to accept default -> %s)" % (default,)
        outdir = default
        outdir_raw = raw_input("> ")
        if outdir_raw == "":
            outdir = os.path.realpath(outdir)
        else:
            outdir = os.path.realpath(os.path.expanduser(outdir_raw))

        if not os.path.isdir(outdir):
            print "%s is not a directory; Create it now? (y, n)" % (outdir,)
            user_choice = raw_input("> ").lower()
            if user_choice == 'y':
                try:
                    os.makedirs(outdir)
                except:
                    print "Failed to create directory; aborting."
                    return None
            elif user_choice == 'n':
                print "Aborting."
                return None

        return outdir

    def export_files(self):
        if (self.scoreDocs is None):
            print "Select documents with \"select [query]\" before exporting TDM"
            return 


        directory = lucene.SimpleFSDirectory(lucene.File(self.lucenedir))
        searcher = lucene.IndexSearcher(directory, True)
        
        outdir = self.choose_or_create_dir('./export/')
        if outdir is None: return

        print "Exporting files to directory", outdir
        searchfiles.write_files(searcher,self.scoreDocs, outdir)


    def export_metadata(self):
        if (self.scoreDocs is None):
            print "Select documents with \"select [query]\" before exporting metadata"
            return 

        directory = lucene.SimpleFSDirectory(lucene.File(self.lucenedir))
        searcher = lucene.IndexSearcher(directory, True)
        
        print "Choose a file for export (leave blank to accept default -> ./metadata.csv)"
        outfile = './metadata.csv'
        outfile_raw = raw_input("> ")
        if outfile_raw == "":
            outfile = os.path.realpath(outfile)
        else:
            outfile = os.path.realpath(os.path.expanduser(outfile_raw))

        print "Exporting files to directory", outfile
        searchfiles.write_metadata(searcher,self.scoreDocs, outfile)




    def show_help(self):
        print """
Supported syntax: 

select [lucene query]
\tSelects all documents in the index matching query [lucene query].

export tdm
\tExports a Term Document Matrix for the selected documents.

export files
\tCopies all selected files to a directory.

analyzer
\tPrints active analyzer and lets you choose a new one.

index
\tPrints a list of available Lucene indices and lets you choose or create one.

view fields
\tPrints a list of all defined fields, and their values, for the selected documents.

quit
\tExits the program.

help
\tDisplays this dialog.
"""
        
if __name__ == '__main__':
    lucene.initVM()
    print 'lucene', lucene.VERSION

    programdir = os.path.join(os.path.dirname(__file__))
    try:
        with open(os.path.join(programdir,'available_indices'), 'r') as inf:
            lucenedir = inf.readline().strip()
            if not os.path.isdir(lucenedir): raise IOError
    except IOError:
        with open(os.path.join(programdir,'available_indices'), 'w') as outf:
            lucenedir = os.path.join(programdir,'lucene_index')
            outf.write(lucenedir)
        
    print "index location:", lucenedir

    if not os.path.exists(lucenedir):
        os.mkdir(lucenedir)
        analyzer = lucene.StandardAnalyzer(lucene.Version.LUCENE_CURRENT)
        writer = lucene.IndexWriter(lucene.SimpleFSDirectory(lucene.File(lucenedir)), analyzer, True, lucene.IndexWriter.MaxFieldLength.LIMITED)
        writer.setMaxFieldLength(1048576)
        writer.optimize()
        writer.close()

    main = TextOrganizer(lucenedir,programdir=programdir)
    main.parseargs(clint.args.grouped)
